/**
 * Contractor Bids API
 *
 * UPDATED: Now uses the new Bids collection instead of embedded quotes.
 * This provides better scalability and management.
 */

import { NextRequest, NextResponse } from 'next/server'
import { getPayload } from 'payload'
import config from '@payload-config'

/**
 * Submit or Update Contractor Bid
 *
 * Allows contractors to submit bids for service requests using the new Bids collection.
 */
export async function POST(request: NextRequest) {
  try {
    const bidData = await request.json()
    const { requestId, contractorId, amount, description } = bidData

    if (!requestId || !contractorId || !amount || !description) {
      return NextResponse.json(
        { error: 'requestId, contractorId, amount, and description are required' },
        { status: 400 },
      )
    }

    const payload = await getPayload({ config })

    // Verify service request exists and is accepting bids
    const serviceRequest = await payload.findByID({
      collection: 'service-requests',
      id: requestId,
      depth: 1,
    })

    if (!serviceRequest) {
      return NextResponse.json({ error: 'Service request not found' }, { status: 404 })
    }

    if (serviceRequest.status === 'completed' || serviceRequest.status === 'cancelled') {
      return NextResponse.json(
        { error: 'This service request is no longer accepting bids' },
        { status: 400 },
      )
    }

    // Check if contractor already has a bid for this request
    const existingBids = await payload.find({
      collection: 'bids',
      where: {
        and: [
          {
            serviceRequest: {
              equals: requestId,
            },
          },
          {
            contractor: {
              equals: contractorId,
            },
          },
        ],
      },
    })

    let bid

    if (existingBids.docs.length > 0) {
      // Update existing bid
      const existingBid = existingBids.docs[0]
      if (!existingBid) {
        throw new Error('Existing bid not found')
      }

      bid = await payload.update({
        collection: 'bids',
        id: existingBid.id,
        data: {
          amount: parseFloat(amount),
          description,
          estimatedDuration: bidData.estimatedDuration,
          warranty: bidData.warranty,
          materials: bidData.materials,
          priceBreakdown: bidData.priceBreakdown,
          availability: bidData.availability,
        },
        depth: 2,
      })
      console.log('üîÑ Updated existing bid:', bid.id)
    } else {
      // Create new bid (title will be auto-generated by the hook)
      bid = await payload.create({
        collection: 'bids',
        data: {
          serviceRequest: requestId,
          contractor: contractorId,
          amount: parseFloat(amount),
          description,
          estimatedDuration: bidData.estimatedDuration,
          warranty: bidData.warranty,
          materials: bidData.materials,
          priceBreakdown: bidData.priceBreakdown,
          availability: bidData.availability,
          status: 'pending',
          title: `Bid for ${serviceRequest.requestTitle}`, // Temporary title, will be updated by hook
        },
        depth: 2,
      })
      console.log('‚ú® Created new bid:', bid.id)
    }

    // Update service request status if it's still pending
    if (serviceRequest.status === 'pending') {
      await payload.update({
        collection: 'service-requests',
        id: requestId,
        data: {
          status: 'receiving-quotes',
        },
      })
    }

    console.log('‚úÖ Bid successfully processed for request:', requestId)

    return NextResponse.json({
      success: true,
      message:
        existingBids.docs.length > 0 ? 'Bid updated successfully' : 'Bid submitted successfully',
      bid: bid,
      serviceRequest: serviceRequest,
    })
  } catch (error: any) {
    console.error('‚ùå Error processing bid:', error)

    // Handle specific PayloadCMS validation errors
    if (error.name === 'ValidationError') {
      return NextResponse.json(
        {
          error: 'Validation error',
          details: error.data || error.message,
          message: 'Please check the provided data and try again',
        },
        { status: 400 },
      )
    }

    return NextResponse.json(
      {
        error: 'Failed to process bid',
        message: 'An unexpected error occurred. Please try again.',
      },
      { status: 500 },
    )
  }
}

/**
 * Get Contractor Bids
 *
 * Retrieves all bids submitted by a specific contractor
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const contractorId = searchParams.get('contractorId')

    if (!contractorId) {
      return NextResponse.json({ error: 'contractorId parameter is required' }, { status: 400 })
    }

    const payload = await getPayload({ config })

    // Find all bids by this contractor
    const contractorBids = await payload.find({
      collection: 'bids',
      where: {
        contractor: {
          equals: contractorId,
        },
      },
      depth: 2,
      sort: '-createdAt',
    })

    // Format the response to include service request info
    const formattedBids = contractorBids.docs.map((bid: any) => ({
      bidId: bid.id,
      requestId: bid.serviceRequest?.id || bid.serviceRequest,
      requestTitle: bid.serviceRequest?.requestTitle || 'Unknown Request',
      serviceType: bid.serviceRequest?.serviceType || [],
      bid: {
        id: bid.id,
        amount: bid.amount,
        description: bid.description,
        status: bid.status,
        estimatedDuration: bid.estimatedDuration,
        warranty: bid.warranty,
        materials: bid.materials,
        priceBreakdown: bid.priceBreakdown,
        availability: bid.availability,
        submittedAt: bid.createdAt,
        acceptedAt: bid.acceptedAt,
        rejectedAt: bid.rejectedAt,
      },
      requestStatus: bid.serviceRequest?.status || 'unknown',
    }))

    return NextResponse.json({
      success: true,
      bids: formattedBids,
      total: contractorBids.totalDocs,
    })
  } catch (error: any) {
    console.error('‚ùå Error fetching contractor bids:', error)
    return NextResponse.json({ error: 'Failed to fetch bids' }, { status: 500 })
  }
}
